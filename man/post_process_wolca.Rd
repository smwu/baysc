% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mcmc_functions_wolca.R
\name{post_process_wolca}
\alias{post_process_wolca}
\title{Post-process posterior samples to relabel and reduce classes for WOLCA}
\usage{
post_process_wolca(MCMC_out, J, R, class_cutoff)
}
\arguments{
\item{MCMC_out}{Output from \code{run_MCMC_Rcpp_wolca} containing:
\describe{
\item{\code{pi_MCMC}}{Matrix of posterior samples for pi. (n_iter)xK}
\item{\code{theta_MCMC}}{Array of posterior samples for theta. (n_iter)xJxKxR}
\item{\code{c_all_MCMC}}{Matrix of posterior samples for c_all. (n_iter)xn}
}}

\item{J}{Number of exposure items}

\item{R}{Maximum number of exposure categories}

\item{class_cutoff}{Minimum class size proportion when determining number of
classes. Default is 0.05.}
}
\value{
Returns list \code{post_MCMC_out} containing:
\describe{
\item{\code{K_med}}{Median, across iterations, of number of classes with at least \code{class_cutoff} percent of individuals}
\item{\code{pi}}{Matrix of reduced and relabeled posterior samples for pi. (n_iter)x(K_med)}
\item{\code{theta}}{Array of reduced and relabeled posterior samples for theta. (n_iter)xJx(K_med)xR}
\item{\code{dendrogram}}{Hierarchical clustering dendrogram used for relabeling}
}
}
\description{
\code{post_process_wolca} conducts post-processing to cluster individuals into a
reduced number of classes and reorder posterior parameter samples according
to the reduced number of classes for the unsupervised WOLCA model.
}
\details{
First, \code{K_med}, the median number of classes with at least the \code{class_cutoff}
proportion of individuals, is obtained over all MCMC iterations. Then, label
switching is addressed through a relabeling procedure, where agglomerative
clustering with Hamming distance is used to group individuals into \code{K_med}
clusters and labels are re-assigned based on these clusters. Finally,
parameter estimates are reordered using the relabeled classes so that
posterior output can be averaged across MCMC iterations.
}
\examples{
  
# Load data and obtain relevant variables
data("sim_data")
data_vars <- sim_data
x_mat <- data_vars$X_data            # Categorical exposure matrix, nxJ
cluster_id <- data_vars$cluster_id  # Cluster indicators, nx1
sampling_wt <- data_vars$sample_wt

# Obtain dimensions
n <- dim(x_mat)[1]        # Number of individuals
J <- dim(x_mat)[2]        # Number of exposure items
R_j <- apply(x_mat, 2,    # Number of exposure categories for each item
             function(x) length(unique(x)))  
R <- max(R_j)             # Maximum number of exposure categories across items 
# Obtain normalized weights
kappa <- sum(sampling_wt) / n   # Weights norm. constant
w_all <- c(sampling_wt / kappa) # Weights normalized to sum to n, nx1

# Set hyperparameters for fixed sampler
K <- 3
alpha <- rep(1, K) / K
eta <- matrix(0.01, nrow = J, ncol = R) 
for (j in 1:J) {
  eta[j, 1:R_j[j]] <- rep(1, R_j[j]) 
}

# First initialize OLCA params
OLCA_params <- init_OLCA(K = K, n = n, J = J, R = R, alpha = alpha, eta = eta)

# Then run MCMC sampling
MCMC_out <- run_MCMC_Rcpp_wolca(OLCA_params = OLCA_params, n_runs = 50, 
burn = 25, thin = 5, K = K, J = J, R = R, n = n, w_all = w_all, x_mat = x_mat, 
alpha = alpha, eta = eta)

# Then run post-process relabeling
post_MCMC_out <- post_process_wolca(MCMC_out = MCMC_out, J = J, R = R,
class_cutoff = 0.05)
# post_MCMC_out
# plot(post_MCMC_out$dendrogram)

}
\seealso{
\code{\link[=post_process]{post_process()}} \code{\link[=run_MCMC_Rcpp_wolca]{run_MCMC_Rcpp_wolca()}} \code{\link[=get_estimates_wolca]{get_estimates_wolca()}}
\code{\link[=wolca_svyglm]{wolca_svyglm()}} \code{\link[=wolca]{wolca()}}
}
