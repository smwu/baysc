% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/var_adjust.R
\name{var_adjust}
\alias{var_adjust}
\title{Post-processing variance adjustment}
\usage{
var_adjust(
  mod_stan,
  estimates,
  K,
  J,
  R,
  n,
  q,
  x_mat,
  y_all,
  V,
  w_all,
  stratum_id,
  cluster_id,
  num_reps = 100
)
}
\arguments{
\item{mod_stan}{Stan model}

\item{estimates}{Output from \code{get_estimates()} containing \code{K_red}, \code{pi_red},
\code{theta_red}, \code{xi_red}, \code{pi_med}, \code{theta_med}, \code{xi_med}, \code{Phi_med}, \code{c_all},
\code{pred_class_probs}, \code{loglik_med}}

\item{K}{Number of classes}

\item{J}{Number of exposure items}

\item{R}{Maximum number of exposure categories}

\item{n}{Number of individuals}

\item{q}{Number of regression covariates excluding class assignment}

\item{x_mat}{Categorical exposure matrix. nxp}

\item{y_all}{Vector of outcomes. nx1}

\item{V}{Regression design matrix without class assignment. nxq}

\item{w_all}{Weights normalized to sum to n. nx1}

\item{stratum_id}{Vector of individual stratum IDs. nx1. Default is \code{NULL},
indicating no stratification.}

\item{cluster_id}{Vector of individual cluster IDs. nx1. Default is \code{NULL},
indicating each individual is their own cluster.}

\item{num_reps}{Number of bootstrap replicates to use for the variance
estimate. Default is 100.}
}
\value{
Returns list \code{estimates_adj} containing:

\describe{
\item{\code{pi_red_adj}}{Matrix of adjusted posterior samples for pi. Mx(K_red)}
\item{\code{theta_red_adj}}{Array of adjusted posterior samples for theta. Mxpx(K_red)xd}
\item{\code{xi_red_adj}}{Array of adjusted posterior samples for xi. Mx(K_red)xq}
\item{\code{pi_med_adj}}{Vector of adjusted posterior median estimates for pi. (K_red)x1}
\item{\code{theta_med_adj}}{Array of adjusted posterior median estimates for theta. px(K_red)xd}
\item{\code{xi_med_adj}}{Matrix of adjusted posterior median estimates for xi. (K_red)xq}
\item{\code{Phi_med_adj}}{Vector of adjusted individual outcome probabilities. nx1}
\item{\code{c_all}}{Vector of final individual class assignments from \code{get_estimates()}. nx1}
\item{\code{pred_class_probs}}{Matrix of individual posterior class probabilities from \code{get_estimates()}. nx(K_red)}
\item{\code{loglik_med}}{Vector of final indiviudal log-likehoods from \code{get_estimates()}. nx1}
}
}
\description{
\code{var_adj} applies applies the post-processing variance adjustment
}
\details{
\code{var_adjust} applies a post-processing variance adjustment that rescales the
variance to obtain correct coverage of posterior intervals, adapted from
Williams and Savitsky (2021). To obtain the rescaling, a sandwich-type
variance is estimated. To estimate the Hessian that composes the "bread" of
the sandwich, the mixture model is specified in Stan and the parameters are
converted to the unconstrained space. Bootstrap replicates are used to
estimate the covariance matrix that composes the "meat" of the sandwich.
If there are any rounding issues, the resulting matrices are mapped to the
nearest positive definite matrix. Next, the rescaling adjustment is derived
and applied to the parameters for all MCMC iterations. Finally, the adjusted
parameters are converted back to the constrained space and the posterior
median parameter estimates are recomputed, now with proper variance estimation.
}
\examples{
# Load data and obtain relevant variables
data("sim_data")
data_vars <- sim_data
x_mat <- data_vars$X_data            # Categorical exposure matrix, nxp
y_all <- c(data_vars$Y_data)         # Binary outcome vector, nx1
cluster_id <- data_vars$cluster_id   # Cluster indicators, nx1
stratum_id <- data_vars$true_Si      # Stratum indicators, nx1
sampling_wt <- data_vars$sample_wt   # Survey sampling weights, nx1

# Obtain dimensions
n <- dim(x_mat)[1]        # Number of individuals
J <- dim(x_mat)[2]        # Number of exposure items
R <- max(apply(x_mat, 2,  # Number of exposure categories
function(x) length(unique(x))))  
# Obtain normalized weights
kappa <- sum(sampling_wt) / n   # Weights norm. constant
w_all <- c(sampling_wt / kappa) # Weights normalized to sum to n, nx1

# Probit model only includes latent class
V <- matrix(1, nrow = n)  
q <- ncol(V)   # Number of regression covariates excluding class assignment

# Set hyperparameters for fixed sampler
K <- 3
alpha <- rep(1, K) / K
eta <- rep(1, R)
mu0 <- Sig0 <- vector("list", K)
for (k in 1:K) {
  # MVN(0,1) hyperprior for prior mean of xi
  mu0[[k]] <- stats::rnorm(n = q)
  # InvGamma(3.5, 6.25) hyperprior for prior variance of xi. Assume uncorrelated
  # components and mean variance 2.5 for a weakly informative prior on xi
  Sig0[[k]] <- diag(LaplacesDemon::rinvgamma(n = q, shape = 3.5, scale = 6.25), 
  nrow = q, ncol = q)
}

# First initialize OLCA params
OLCA_params <- init_OLCA(K = K, n = n, J = J, R = R, alpha = alpha, eta = eta)

# Then initialize probit params 
probit_params <- init_probit(K = K, n = n, q = q, V = V, mu0 = mu0, 
Sig0 = Sig0, y_all = y_all, c_all = OLCA_params$c_all)

# Then run MCMC sampling
MCMC_out <- run_MCMC_Rcpp(OLCA_params = OLCA_params, 
probit_params = probit_params, n_runs = 50, burn = 25, thin = 5,
K = K, J = J, R = R, n = n, q = q, w_all = w_all, x_mat = x_mat, 
y_all = y_all, V = V, alpha = alpha, eta = eta, Sig0 = Sig0, mu0 = mu0)

# Then run post-process relabeling
post_MCMC_out <- post_process(MCMC_out = MCMC_out, J = J, R = R, q = q,
class_cutoff = 0.05)

# Then obtain posterior estimates
estimates <- get_estimates(MCMC_out = MCMC_out, post_MCMC_out = post_MCMC_out,
                           n = n, J = J, V = V, y_all = y_all, x_mat = x_mat)

# Finally apply variance adjustment to posterior estimates
adj_estimates <- var_adjust(mod_stan = stanmodels$SWOLCA_main, 
                            estimates = estimates, K = K, J = J,
                            R = R, n = n, q = q, x_mat = x_mat, y_all = y_all,
                            V = V, w_all = w_all, stratum_id = stratum_id, 
                            cluster_id = cluster_id, num_reps = 100)                        

}
\seealso{
\code{\link[=run_MCMC_Rcpp]{run_MCMC_Rcpp()}} \code{\link[=post_process]{post_process()}} \code{\link[=get_estimates]{get_estimates()}} \code{\link[=swolca]{swolca()}}
}
